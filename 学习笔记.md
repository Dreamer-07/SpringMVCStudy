# 第一章 初识SpringMVC 

## 1.1 SpringMVC 简介

- Spring 操作 Web 模块，简化 Web 开发
  <img src="D:\StudyCode\Spring5\Resources\笔记\分析图\Spring5模块.bmp" alt="Spring5模块" style="zoom:80%;" />

  SpringMVC == Spring中 的 Web 模块

- Spring 为 展现层 提供的基于 MVC 设计理念的 Web 框架
  <img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20200901101001860.png" alt="image-20200901101001860" style="zoom:80%;" />

  回顾MVC

- 可以通过 MVC 注解，使 POJO 称为处理请求的控制器，而无需实现任何借口

  - POJO：一个普通的 Java 类

- 支持 REST 风格的 URL 请求

- 采用了松散耦合的可插拔组件结构，具有扩展性和灵活性

## 1.2 SpringMVC 的 MVC 思想

<img src="https://user-gold-cdn.xitu.io/2019/12/10/16eef2a556cb2078?imageslim" alt="img" style="zoom:80%;" />

## 1.3 HelloWorld

1. 在 IDEA 中创建 Maven WEB 工程

2. 导入所需依赖(核心容器模块 + web 模块)

   ```xml
   <!-- Spring 核心容器 -->
   <dependency>
       <groupId>org.springframework</groupId>
       <artifactId>spring-context</artifactId>
       <version>${spring.version}</version>
   </dependency>
   <!-- Spring Web模块 -->
   <!-- web组件 -->
   <dependency>
       <groupId>org.springframework</groupId>
       <artifactId>spring-web</artifactId>
       <version>${spring.version}</version>
   </dependency>
   <!-- WebMVC 组件 -->
   <dependency>
       <groupId>org.springframework</groupId>
       <artifactId>spring-webmvc</artifactId>
       <version>${spring.version}</version>
   </dependency>
   ```

3. 在 web.xml 中配置前端控制器

   ```xml
   <!-- SpringMvc需要一个前端控制器负责拦截请求，并智能派发
           这个前端控制器本质上就是一个 Servlet ，所以需要在 web.xml 下配置
      -->
   <servlet>
   	<servlet-name>springDispatcherServlet</servlet-name>
       <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
       <init-param>
           <!-- SpringMVC (Spring) 配置文件的位置 -->
           <param-name>contextConfigLocation</param-name>
           <param-value>classpath:Application/SpringMVC.xml</param-value>
       </init-param>
       <!--
        load-on-startup:可以使对应的 Servlet 程序在Tomcat服务器启动后就创建对象，而不是第一次访问时再创建
                        对应的参数越小，优先级越高，越先创建对象
        -->
       <load-on-startup>1</load-on-startup>
   </servlet>
   <servlet-mapping>
       <servlet-name>springDispatcherServlet</servlet-name>
       <!--
       / 和 /* 的区别
         /  : 能拦截除了 jsp 文件之外的请求，保证jsp可以正确访问
         /* : 能拦截所有请求，包括 jsp 文件
       -->
       <url-pattern>/</url-pattern>
   </servlet-mapping>
   ```

4. 在 SpringMVC.xml 中开启 **组件**扫描

5. 创建两个基本的 jsp 页面
   <img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20200901121524364.png" alt="image-20200901121524364" style="zoom:80%;" />

6. 创建第一个控制器 MyFirstController.java (一个普通的 Java 类)

   ```java
   @Controller //告诉 SpringMVC 这是一个 控制器组件，可以处理请求
   public class MyFirstController {
   
       /*
       * @RequestMapping：配置接收可以接收的请求地址
       *   / 代表当前工程目录下，映射到 webapp 目录
       * */
       @RequestMapping("/hello")
       public String hello(){
           System.out.println("收到请求，正在处理...");
           return "/WEB-INF/pages/success.jsp";
       }
   
   }
   ```

7. 在 SpringMVC 配置文件中配置视图解析器，简化返回值的地址

   ```xml
   <!-- 配置视图解析器，帮助我们拼接返回页面的地址 -->
   <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
       <!-- 配置两个属性,prefix 和 suffix -->
       <property name="prefix" value="/WEB-INF/pages/"></property>
       <property name="suffix" value=".jsp"></property>
   </bean>
   ```

8. 修改源控制器程序代码

   ```java
   /*
   * @RequestMapping：配置接收可以接收的请求地址
   *   / 代表当前工程目录下，映射到 webapp 目录
   * */
   @RequestMapping("/hello")
   public String hello(){
       System.out.println("收到请求，正在处理...");
       //return "/WEB-INF/pages/success.jsp"; //使用视图解析器，简化返回的路径
       /*
       *   <property name="prefix" value="/WEB-INF/pages/"></property>
       <property name="suffix" value=".jsp"></property>
       * 该方法的返回的值，最后会被拼接为 /WEB-INF/pages/success.jsp
       * */
       return "success";
   }
   ```

## 1.4 HelloWorld 中的细节补充

### 1.4.1 运行流程

1. 前端 JSP 页面发送请求，地址为：http://localhost:8080/01_HelloWorld/hello
2. Tomcat 服务器接收请求
3. 将请求**交给 SpringMVC 的前端控制器**进行派发
4. SpringMVC 前端控制器将请求地址和 控制器类的**@RequestMapping注解的值** 进行比较，找到目标控制类以及方法
5. 通过**反射**调用该方法
6. 如果该方法有返回值，SpringMVC 会认为这就是请求**处理后需要转发**的地址
7. 通过 SpringMVC 的配置的视图解析器，**拼接**完整的请求转发地址
8. 有前端控制器完成 **请求转发**

### 1.4.2 @RequestMapping 

> 详情请看第二章

### 1.4.3 不指定配置文件的默认配置文件

- 如果在 web.xml 中不指定配置文件，则需要在 WEB-INF 目录下创建一个
  对应 **前端控制器名(servlet-name)-servlet.xml 的 Spring** 配置文件
  ![image-20200901151103173](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20200901151103173.png)

### 1.4.4 web.xml 中 前端控制器 url-pattern 的设置

1. / 和 /* 的区别
   - / 会拦截除了 jsp 外的请求
   - /* 会拦截所有请求
   - 但二者都会拦截静态资源，后者只因为本身的配置，前者则是覆盖了 Tomcat 的 web.xml 中的配置
2. Tomcat 的 web,xml
   - 所有部署在 Tomcat 的 WEB 项目 中的 web.xml 都继承于 Tomcat 本身配置的 web.xml
   - Tomcat 中使用了 DefaultServlet 来处理除了 jsp 和 Servlet 外的静态资源，对于静态资源，Tomcat 会找到后返回
     <img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20200901152706017.png" alt="image-20200901152706017" style="zoom:80%;" />
   - 而当前端控制器 Servlet 将 url-pattern 设置为 / 时，则会禁用 DefaultServlet ，导致静态资源无法访问
   - 而对于 JSP ，Tomcat 默认使用的是 JspServlet 拦截该请求，其 url-pattern 的参数值为 *.jsp
     所以并不会被 前端控制器 拦截

# 第二章 @RequestMapping 映射请求

## 2.1 用于方法

- 负责告诉 SpringMVC 该方法接收的请求地址
- /可以不加，默认都是从本项目下开始找
- 一个方法处理一个请求



## 2.2 用于类

- 为当前类所有方法的请求地址前面额外指定一个基准路径

- 是基准路径不是 拼串前缀

  ```java
  @RequestMapping("/emt")
  @Controller
  public class RequestMappingTestController {
  
      @RequestMapping("/haha") //访问该方法的请求路径仍然是 /emt/haha，而不是/emthaha
      public String haha(){
          System.out.println("收到请求，正在处理...");
          return "success";
      }
  
  }
  ```

- 用在类上后，该类中的方法的 
  @RequestMapping 的值 
  可以和别的控制器方法的 @RequestMapping 的
  值一样

- 但访问的真实路径(加上基准路径后的路径)，仍不能相同

  

## 2.3 其他属性

1. method：限定请求方式

   - HTTP中的所有请求方式 【GET】, HEAD,【POST】, PUT, PATCH, DELETE, OPTIONS, TRACE

   - 属性值为 RequestMethod 枚举类的对象值

     ```java
     /*
     * 使用 method 后，代表该方法只接收指定请求方式的请求
     * 可以指定多个，如：{RequestMethod.POST,RequestMethod.GET}
     * */
     @RequestMapping(value = "/method",method = RequestMethod.POST)
     public String method(){
         return "success";
     }
     ```

   

2. params：规定请求参数

   - –param1: 表示请求必须包含名为 param1 的请求参数
         可以为空值("")不能不带

   - –!param1: 表示请求不能包含名为 param1 的请求参数

     ​				   为空值("")也不行，不能带

   - –param1 != value1: 表示请求包含名为 param1 的请求参数，但其值不能为 value1

     ​								   可以为空(null)也可以为空值("")，打不能试 value1

   - –{“param1=value1”, “param2”}: 请求必须包含名为 param1 和param2 的两个请求参数，且 param1 参数的值必须为 value1

     ​														必须都符合规则才行




3. headers：规定请求头参数

   - 规则和 params 属性值一样

   - ```java
     @RequestMapping(value = "headers",headers = {"User-Agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:79.0) Gecko/20100101 Firefox/79.0"})
     public String headers(){
         return "success";
     }
     ```

4. consumes：规定只接受指定内容类型的请求，相当于请求头中的 Content-Type

5. produces：告诉游览器返回的内容类型，相当于响应头的 Content-Type

   

## 2.4 模糊匹配

> RequestMapping注解对于请求地址的Ant风格的模糊匹配

- Ant风格：之前自动构建工具Ant匹配资源时使用的一套通配符参数

- 通配符参数：

  -  ?：匹配文件名中的一个字符
  -  *：匹配文件名中的任意字符和一层路径
  -  **: 匹配多层路径     

- ```java
  @RequestMapping("/antTest01") //精准匹配
  public String antTest01(){
      System.out.println("antTest01....");
      return "success";
  }
  
  /*
  * ?匹配一个字符，0个或多个都不写
  * */
  @RequestMapping("/antTest0?")
  public String antTest02(){
      System.out.println("antTest02....");
      return "success";
  }
  
  /*
  * *匹配多个字符，且可以代表一层路径 - *的位置上可以为空
  * */
  @RequestMapping("/a*/antTest0*")
  public String antTest03(){
      System.out.println("antTest03....");
      return "success";
  }
  
  /*
  * **匹配多层路径 - **可以为空
  * */
  @RequestMapping("/a/**/antTest")
  public String antTest04(){
      System.out.println("antTest04....");
      return "success";
  }
  ```

   **优先级**：精确 > ? > * > **

## 2.5 @PathVariable 获取路径上的占位符

```java
 /*
 * @PathVariable 可以获取路径上的占位符
 * 在声明 @RequestMapping 的路径时可以在任意路径的地方写一个{变量名}
 * */
@RequestMapping("/{username}/pathVariable{abc}")
public String pathVariableTest(@PathVariable("abc") String username){
    System.out.println("username = " + username);
    return "success";
}
```

## 2.6 REST

> 系统希望以非常简洁的 URL 地址来发送请求，
>
> 对于一个资源的不同操作方式，我们采用请求方式来区分

- 请求地址格式：/资源名/资源标识符
- 根据不同的请求方式，指定不同的操作方式
  1. GET > 获取某个资源
  2. PUT > 更新某个资源
  3. DELETE > 删除某个资源
  4. POST > 添加某个资源
- 以简洁的 URL 地址提交请求，以请求方式来区分不同的操作方式
- 但存在一个问题：就是页面上无法直接使用除了 GET 和 POST 外的请求方式 

### 2.6.1 实现REST风格的增删改查

1. 基本环境搭建 - 完成 POST 和 GET 请求

2. 使用 Spring 完成对 Rest 风格的支持(针对 DELETE 和 PUT 请求)

   - 配置 SpringMVC 中的一个 Filter，该 Filter 的主要功能是将普通的请求转换为指定形式的请求
     (在 web.xml 下完成如下配置)

     ```xml
     <filter>
         <filter-name>hiddenHttpMethodFilter</filter-name>
         <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>
     </filter>
     <filter-mapping>
         <filter-name>hiddenHttpMethodFilter</filter-name>
         <url-pattern>/*</url-pattern>
     </filter-mapping>
     ```

   - 创建一个 POST 类型的表单

   - 给表单项中定义一个 name 为 _method 的参数

   - 该 _method 表单项的值就是你需要转换的请求方式(DELETE / PUT)，不区分大小写

     ```jsp
     <%--
      完成 Spring 对于 REST 风格的支持
         对于需要发送 DELETE 和 PUT 请求方式的请求，完成如下步骤
             1. 创建一个表单，该表单的提交方式为 POST
             2. 创建一个表单项，name 属性值为 _method
             3. _method 表单项的 value 属性值就是需要转换的请求方式
      --%>
     <form action="book/1" method="post">
         <input type="hidden" name="_method" value="DELETE">
         <input type="submit" value="删除图书信息">
     </form>
     <br/>
     
     <form action="book/1" method="post">
         <input type="hidden" name="_method" value="PUT">
         <input type="submit" value="更新图书信息">
     </form>
     <br/>
     ```

3. 高版本对于 PUT 和 DELETE 请求的限制

   - Tomcat8 中对 JSP 的约束，会导致执行以上步骤后，导致 405 错误
     解决方法：在 JSP 页面的 page 指令中，指定该页面为一个异常页面

     ```jsp
     <%@ page language="java" contentType="text/html; charset=UTF-8"
              pageEncoding="UTF-8" isErrorPage="true" %>
     ```

   - 对于 Tomcat9 有以下的方法解决

     1. 在对应的处理方法的类上额外加上 @ResponseBody / @RestController 注解 
        这种方法不会将返回值重新请求转发到页面

     2. 重定向到新的请求 jsp 页面 / 新的方法由来完成请求转发

        ```java
        //重定向到没有指定 method 属性的方法
        @RequestMapping(value = "/testMethod/{id}" , method = RequestMethod.DELETE)  
        public String testMethodDELETE(@PathVariable(value = "id") Integer id) {  
            System.out.println("testMethod: DELETE: "+ id);  
            return "redirect:/springmvc/success"; //重定向到一个没有指定 method的 Handler方法   
        }
        
        @RequestMapping(value = "/success")  
        public String successGenecal() {  
            return "success";  //由该方法 转发到success.jsp页面
        }
        ```

        ```java
        //重定向到页面
        @RequestMapping(value = "/testMethod/{id}" , method = RequestMethod.PUT)  
        public String testMethodPUT(@PathVariable(value = "id") Integer id) {  
            System.out.println("testMethodPUT: PUT: "+ id);  
            return "redirect:/success.jsp";
        }  
        ```

        

4. HiddenHttpMethodFilter 源码解析(Spring5.x)

   ```java
   @Override
   protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
         throws ServletException, IOException {
   	
      HttpServletRequest requestToUse = request;
   	//判断请求的方式是否为 POST 请求 && 请求没有错误
      if ("POST".equals(request.getMethod()) && request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) == null) {
          //获取请求中 _method 的 value 属性值
         String paramValue = request.getParameter(this.methodParam); // methodParam == _method
         if (StringUtils.hasLength(paramValue)) { //如果不等于null或""
            String method = paramValue.toUpperCase(Locale.ENGLISH); //转小写
            if (ALLOWED_METHODS.contains(method)) { //如果是PATCH,PUT,DELETE请求
                /*
                创建一个新的 request 请求对象，该请求对象重写了 getMethod() 方法，使其返回值为转换后的请求方式
                */
               requestToUse = new HttpMethodRequestWrapper(request, method); 
            }
         }
      }
   
      filterChain.doFilter(requestToUse, response);
   }
   ```

# 第三章 处理请求信息

## 3.1 @RequestParam - 获取请求参数

### 3.1.1 默认方式

- 在方法参数中，指定一个和请求参数名相同的变量，这个变量会自动接收请求参数中的值

- 如果请求参数中没有该值，就为 null

- ```java
  /* 获取请求参数方式1 - 默认方式
  *  将方法的参数名命名为何请求参数名相同即可，会自动接收请求参数，如果没有则为 null
  * */
  @RequestMapping("/requestValue") //测试获取请求参数
  public String requestValueTest(String username){
      System.out.println("username = " + username);
      return "success";
  }
  ```

### 3.1.2 使用 @RequestParam 注解

- 为方法参数添加一个 @RequestParam 注解，指定其 value 属性值为请求参数名

- 默认情况下如果请求是**不带**该参数，为报错

- 可以通过设置其 required 属性值改变

- ```java
  /* 获取请求参数方式2 - 使用 @RequestParam 注解
  *       指定请求参数名即可为对应的参数自动赋值
  *       默认情况下，如果没有带请求参数，会报错
  *       通过required的属性值可以解决:
  *           - required:该参数是否为必须的，默认为true，如需可以改成false，代表可以为参数值可以不带(null)
      *       - defaultValue:该参数的默认值
      * */
  @RequestMapping("/requestValue")
  public String requestValueTest(@RequestParam(value = "username",required = false,defaultValue = "1") String username){
      System.out.println("username = " + username);
      return "success";
  }
  ```



## 3.2 @RequestHeader - 获取请求头中某个 key 的值

- 为方法的参数添加一个 @RequestHeader 注解，指定其 value 值为请求头中的 key

- 如果 value 值是请求头中不存在的 key，那么就会报错

- 可以修改注解属性 required 为 false 解决该错误

- ```java
  /*
  * 获取请求头中的信息 - 使用 @RequestHeader 注解
  *   正常情况下，指定请求头中的 key 值即可
  *   如果获取的是请求头中不存在的 key，那么就会报错
  *       解决方式和 @RequestParam 一样，指定 required 属性值
  *   也可以额外指定 defaultValue 属性值
  * */
  @RequestMapping("/requestHeader")
  public String requestHeader(@RequestHeader(value = "HAHAHA",required = false) String userAgent){
      System.out.println("User-Agent = " + userAgent);
      return "success";
  }
  ```



## 3.3 @CookieValue - 获取某个 cookie 的值

- 为方法的参数添加一个 @CookieValue 注解，指定其 value 值为 Cookie 中的 key

- 其他情况和以上两个注解相同

- ```java
  /*
  * 获取 Cookie 中的值 - 使用 @CookieValue 注解
  *       默认情况下，指定其 value 值为需要获取 cookie 的 key 值即可
  *       但如果请求的 cookie 中没有该 key，就会报错
  *           同样，可以设置器 required 为 false 解决
  *       也可以额外指定 defaultValue 属性值
  * */
  @RequestMapping("/cookieValue")
  public String cookieValue(@CookieValue(value = "JSESSIONID",required = false) String jid){
      System.out.println("JSESSIONID = " + jid);
      return "success";
  }
  ```



## 3.4 使用 POJO 对象绑定请求参数 

> POJO：一个不包含业务逻辑，仅用来存储数据的 Java 类(就是一个普通的 JavaBean)，一般不实现任何接口，也不继承某个类(Object 类除外)

1. 先创建一个 POJO 类 Book

   ```java
   public class Book {
       private String name;
       private String author;
   
       public Book() {
       }
   
       public Book(String name, String author) {
           System.out.println("通过构造方法设置");
           this.name = name;
           this.author = author;
       }
   
       public String getName() {
           return name;
       }
   
       public void setName(String name) {
           System.out.println("通过set方法设置");
           this.name = name;
       }
   
       public String getAuthor() {
           return author;
       }
   
       public void setAuthor(String author) {
           System.out.println("通过set方法设置");
           this.author = author;
       }
   
       @Override
       public String toString() {
           return "Book{" +
                   "name='" + name + '\'' +
                   ", author='" + author + '\'' +
                   '}';
       }
   }
   ```

2. 在 JSP 中创建一个表单，该表单中表单项的 name 值和对应 POJO 中的属性名相同

   ```jsp
   <%--
    创建一个表单，设置表单中的表单项的 name 值和 POJO 类中对应的属性名相同
    --%>
   <form action="book" method="post">
       书名：<input name="name">
       作者名：<input name="author">
       <input type="submit" value="添加新图书">
   </form>
   ```

3. 设计对应的 Controller 控制器方法

   ```java
   @RequestMapping(value = "/book",method = RequestMethod.POST)
   public String addBook(Book book){ //方法参数中指定对应的 POJO 对象
       System.out.println(book);
       return "success";
   }
   ```

4. 会通过 set 方法将请求参数的值注入到 POJO 的对象属性中

5. 同样，也可以完成级联赋值(通过一个 POJO 对象 完成对另一个 POJO 对象的赋值)

   1. 设计 POJO 类 Address

      ```java
      public class Address {
          private String city;
          private String country;
      
          public Address() {
          }
      
          public Address(String city, String country) {
              this.city = city;
              this.country = country;
          }
      
          public String getCity() {
              return city;
          }
      
          public void setCity(String city) {
              this.city = city;
          }
      
          public String getCountry() {
              return country;
          }
      
          public void setCountry(String country) {
              this.country = country;
          }
      
          @Override
          public String toString() {
              return "Address{" +
                      "city='" + city + '\'' +
                      ", country='" + country + '\'' +
                      '}';
          }
      }
      ```

   2. 重新设计 Book 类，添加 Address 对象属性

      ```java
      public class Book {
          private String name;
          private String author;
          private Address address;
          
          public Book() {
          }
      
      	public Book(String name, String author, Address address) {
              this.name = name;
              this.author = author;
              this.address = address;
          }
          
          this.author = author;
          }
      
          public Address getAddress() {
              return address;
          }
      
          public void setAddress(Address address) {
              this.address = address;
          }
      
          @Override
          public String toString() {
              return "Book{" +
                      "name='" + name + '\'' +
                      ", author='" + author + '\'' +
                      ", address=" + address +
                      '}';
          }
      }
      ```

   3. 修改 pojo.jsp 中的表单

      ```jsp
      <%--
       创建一个表单，设置表单中的表单项的 name 值和 POJO 类中对应的属性名相同
       --%>
      <form action="book" method="post">
          书名：<input name="name">
          作者名：<input name="author">
          <hr>
          <%--
          对于需要级联赋值的表单项，其 name 属性值为 级联对象属性的属性
          --%>
          作者-国家：<input name="address.country"> <br/>
          作者-城市地址：<input name="address.city"> <br/>
          <input type="submit" value="添加新图书">
      </form>
      ```



## 3.5 方法参数中传入原生 API	

- SpringMVC 支持在对应的方法参数中，直接获取原生的 API 使用

  ```java
  @RequestMapping("/API")
  public String testAPI(HttpSession session){
      session.setAttribute("key1","value1");
  	return "success";   
  }
  ```

- 其中仅支持直接获取以下的原生 API

  ```
  1. HttpServletRequest
  2. HttpServletResponse
  3. HttpSession
  4. java.security.Princeipal - 与 HTTPS 安全协议相关的
  5. Locale - 国际化对象
  6. InputStream - ServletInputStream inputStream = request.getInputStream();
  7. OutputStream - ServletOutputStream outputStream = response.getOutputStream();
  8. Reader - BufferedReader reader = request.getReader();
  9. Writer - PrintWriter writer = response.getWriter();
  ```

## 3.6 使用 CharacterEncodingFilter 编码过滤器解决乱码问题

- 对于 GET 请求，需要在 Tomcat 服务器安装目录下的 conf/server.xml 配置以下代码

  ```xml
  <Connector port="8080" protocol="HTTP/1.1"
             connectionTimeout="20000"
             redirectPort="8443"
             URIEncoding="UTF-8"  /> <!-- 这里就是在设置端口处，添加 URIEncoding="UTF-8" -->
  ```

- 对于 POST 请求以及 Response 响应乱码，需要在项目中的 web.xml 配置 SpringMVC 提供的  CharacterEncodingFilter 编码过滤器

  ```xml
  <!-- 配置编码过滤器 -->
  <filter>
      <filter-name>CharacterEncodingFilter</filter-name>
      <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
      <!-- encoding：设置需要的编码格式 -->
      <init-param>
          <param-name>encoding</param-name>
          <param-value>UTF-8</param-value>
      </init-param>
      <!--  forceRequestEncoding：是否设置POST请求的编码，默认为false -->
      <init-param>
          <param-name>forceRequestEncoding</param-name>
          <param-value>true</param-value>
      </init-param>
      <!--  forceRequestEncoding：是否设置响应时的编码，默认为false -->
      <init-param>
          <param-name>forceResponseEncoding</param-name>
          <param-value>true</param-value>
      </init-param>
  </filter>
  <filter-mapping>
      <filter-name>CharacterEncodingFilter</filter-name>
      <url-pattern>/*</url-pattern>
  </filter-mapping>
  ```

- 注意，对于 CharacterEncodingFilter 编码过滤器其配置一般都放在**其他过滤器之前**
  防止其他过滤器中已经使用了 request 导致编码失败



# 第四章 数据输出

## 4.1 在方法处传入 Map/Model/ModelMap

> 在方法内给这些方法参数保存的数据都会被存放在 request 域中

- 代码实例

```java
@RequestMapping("/map")
public String outMapTest(Map<String,Object> map){
    map.put("msg","EMT"); //给方法形参的map保存数据
    return "success";
}

@RequestMapping("/model")
public String outModelTest(Model model){ //Model 是一个接口
    model.addAttribute("msg","EMT!"); //保存数据到方法形参 model 中
    return "success";
}

@RequestMapping("/modelMap")
public String outModelMapTest(ModelMap modelMap){
    modelMap.addAttribute("msg","EMT!!"); //保存数据到方法形参 modelMap 中
    return "success";
}
```

(测试使用的 JSP - success.jsp)

```jsp
pageContext: ${pageScope.msg} <br/>
request:${requestScope.msg} <br/>
session:${sessionScope.msg} <br/>
Application:${applicationScope.msg}
```



- 三者关系：无论使用哪一种，其最后都是由 BindingAwareModelMao 来完成
      相当于给 BindingAwareModelMap 保存的数据都会存在在 request 域中

  ```
  Map(interface(JDK))			Model(interface(Spring))
  	||								//
  	||(实现)						  //
  	\/							  //
  ModelMap(class)					 //
    			\\					//
    			 \\(继承)           //(实现)
    			ExtendedModelMap(class)
              		  ||(继承)
              		  \/
              BindingAwareModelMap
  ```

  

## 4.2 方法的返回值类型为 ModelAndView

> 该对象中既可以保存 Model(给页面的模型数据) 和 View (视图信息，也就是页面地址)

- 通过该对象保存的数据，都可以在 request 域中获取

(代码实例)

```java
@RequestMapping("/modelAndView")
public ModelAndView testMAV(){
    //创建 ModelAndView 对象时，可以通过有参构造器，可以指定视图名
    //视图名随后会被视图解析器，添加上对应的前缀和后缀，组成真实的资源路径
    ModelAndView mv = new ModelAndView("success");
    //mv.setViewName("success"); //也可以通过 setViewName 方法设置视图名
    
    //通过 addObject() 添加对应的数据，该数据可以通过 request 域获取
    mv.addObject("msg","EMT!!!");
    return mv;
}
```



## 4.3 为类添加 @SessionAttributes 注解

> 不推荐使用的，更建议使用原生 API 来向 session 中添加数据

- 该注解直接在类上，当我们通过 Model/Map/ModelMap/ModelAndView 向 request 域中添加数据时，也会将 **符合规则** 的数据保存在 session 域中

- 它可以指定以下两个属性值(定制规则)

  - value：可以指定多个 String 属性值，代表当向 request 存放数据时，如果 key 和 其中的属性值相同时，就会保存到 session 域中
  - types：可以指定多个 Class 属性值，代表当向 request 存放数据时，如果 value 的数据类型和其中的属性值相同时，就会保存到 session 域中

- ```java
  @SessionAttributes(value = {"msg"},types = {Integer.class})
  @Controller
  public class OutPutController{
      ...
  }
  ```



## 4.4 @ModelAttribute(不常用)

### 4.4.1 使用场景

- 页面-修改图书的信息
  <img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20200902154853975.png" alt="image-20200902154853975" style="zoom:80%;" />

- 提交给 servlet 调用 dao

  ```java
  String sql = "UPDATE book VALUES(?,?,?,?,?) WHERE id = ?";
  dao.update(sql,book.getName(),
            book.getPrice(),
            book.getAuthor(),
            book.getSales(),
            book.getStock(),
            book.getId())
  ```

- 但实际业务中，并不会进行全字段修改，只会修改部分字段
  比如用户信息中，只能修改 密码等等信息，而不能修改账号

- 所以 - 不建议将不修改的字段放在页面上进行展示

  (此时引入一个问题)

1. 为了简单操作，我们会在 Controller 中的方法中创建一个对应 POJO 类的对象，自动进行封装
2. 但如果接下来如果我们仍然使用全字段更新的 DAO 操作，可能会出现有字段为 null 的情况

### 4.4.2 解决思路

1. 不让 SpringMVC 直接通过空参构造器创建对象
   而是通过将 **数据库中对应的字段的数据** 先封装成一个 POJO 类对象 

2. 没有提供对应请求参数值的属性，使用之前在数据库查询到的即可

   提供了对应请求参数值的属性，重新注入为请求参数值

3. 调用全字段更新即可

### 4.4.3 @ModelAttribute 的使用

#### 作用在方法上

- 该方法会比 @RequestMapping 注解的目标方法先进行
- 在该方法中，使用 Map/Model/ModelMap 作为方法参数
- 将查询到的 数据库数据封装为 POJO 类对象后，保存在对应的 Map/Model/ModelMap 中

#### 作用在参数上

- 作用在对应的 POJO类对象 的方法参数上
- 通过指定其注解属性值 value ，获取刚刚在于先前方法中保存在 Map/Model/ModelMap 的数据
- 而 value 的属性值就是刚刚保存数据时使用的 key 值
- SpringMVC 仍会自动将带有请求参数值注入到对应属性

```java
//作用在参数上
@RequestMapping("/book")
public String updateBook(@ModelAttribute("book") Book book){
    System.out.println("修改之后的图书信息:" + book); //Book{id=1, bookName='胰脏物语', author='OHHH', price=59.9}
    return "success";
};

//作用在方法上
@ModelAttribute
public void getBookById(Model model,Integer id){
    //这里先模拟从数据库中查询出对应的数据
    Book book = new Book(id, "胰脏物语", "住野よる", 60.0);
    System.out.println("数据库中查询到的数据：" + book); //Book{id=1, bookName='胰脏物语', author='住野よる', price=60.0}
    //间数据保存在对应的 model 中
    model.addAttribute("book",book);
}
```



### 4.4.4 原理

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20200902165857870.png" alt="image-20200902165857870" style="zoom:80%;" />

- 通过上图，我们还有一种方法可以获取先行方法保存在 Map/Model/ModelMap 中的数据
  1. 在目标方法中，将 Map/Model/ModelMap  作为方法参数
  2. 通过对应的 getXxx() 方法获取刚刚保存在 BindingAwareModelMap 中的数据



# 第五章 源码解析 - 基于 Spring5(未完待续)

> Spring4 和 Spring5 的有一定区别

## 5.1 前端控制器 DispatcherServlet 结构分析

- (通过查看源码可得下图)
  <img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20200903085153690.png" alt="image-20200903085153690" style="zoom:80%;" />



## 5.2 请求处理的大致流程

- 从 5.1 可以看出，最后执行的方法时 DispatcherServlet 中的 doDispatch() 方法
- 通过观察该方法中的源码，就可以了解 SpringMVC 是如何处理请求转发的

### 5.2.1 doDispatch() 方法

(源码解析)

```java
protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
    HttpServletRequest processedRequest = request;
    HandlerExecutionChain mappedHandler = null;
    boolean multipartRequestParsed = false;

    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);

    try {
        ModelAndView mv = null;
        Exception dispatchException = null;

        try {
            //检查是否是文件上传请求，如果是，会包装一个新的请求
            processedRequest = checkMultipart(request);
            /*
            如果 processedRequest 和 request 不等，代表该请求就是 上传请求，multipartRequestParsed = true
            如果 					...		   相等，   ...  不是 ...   ，multipartRequestParsed = flase
            */
            multipartRequestParsed = (processedRequest != request);

            // 根据请求地址找到对应的控制器类以及目标方法
            mappedHandler = getHandler(processedRequest);
            // 如果没有找到就抛出404页面/异常
            if (mappedHandler == null) {
                noHandlerFound(processedRequest, response);
                return;
            }

            // 获取能处理目标方法的适配器(反射工具)
            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());

            // Process last-modified header, if supported by the handler.
            String method = request.getMethod();
            boolean isGet = "GET".equals(method);
            if (isGet || "HEAD".equals(method)) {
                long lastModified = ha.getLastModified(request, mappedHandler.getHandler());
                if (new ServletWebRequest(request, response).checkNotModified(lastModified) && isGet) {
                    return;
                }
            }

            if (!mappedHandler.applyPreHandle(processedRequest, response)) {
                return;
            }

            //！！！通过适配器执行了对应的目标方法
            /*
            适配器会将目标方法的返回信息封装成 ModelAndView 类对象并返回
            */
            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());

            if (asyncManager.isConcurrentHandlingStarted()) {
                return;
            }
			//该方法内会判断 由刚刚目标方法返回信息封装的 ModelAndView类对象 是否有视图名，如果没有，就会默认设置一个
            applyDefaultViewName(processedRequest, mv);
            mappedHandler.applyPostHandle(processedRequest, response, mv);
        }
        catch (Exception ex) {
            dispatchException = ex;
        }
        catch (Throwable err) {
            // As of 4.3, we're processing Errors thrown from handler methods as well,
            // making them available for @ExceptionHandler methods and other scenarios.
            dispatchException = new NestedServletException("Handler dispatch failed", err);
        }
        //！！！在这里完成了对请求页面的转发
        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
    }
    catch (Exception ex) {
        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);
    }
    catch (Throwable err) {
        triggerAfterCompletion(processedRequest, response, mappedHandler,
                               new NestedServletException("Handler processing failed", err));
    }
    finally {
        if (asyncManager.isConcurrentHandlingStarted()) {
            // Instead of postHandle and afterCompletion
            if (mappedHandler != null) {
                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);
            }
        }
        else {
            // Clean up any resources used by a multipart request.
            if (multipartRequestParsed) {
                cleanupMultipart(processedRequest);
            }
        }
    }
}
```

(文字总结)

1. 发送请求，DispatcherServlet  收到请求，

2. 调用 doDispatch() 方法处理

   1. 判断是否是文件上传请求

   2. getHandler() - 获取到请求地址对应的处理器类以及目标方法

      > 根据请求地址在对应的 HandlerMapping 中获取这个请求映射信息 - handler 属性(处理器类以及目标方法)

   3. getHandlerAdapter() - 获取对应的目标方法的适配器

      > 根据 handler 在 this.handlerAdapters 找到对应的 HandlerAdapter(适配器)

   4. 使用获取到的适配器执行目标方法

   5. 适配器执行后会得到一个 ModelAndView 类对象

   6. 根据 ModelAndView 中封装的信息转发到具体的页面，并将模型数据保存至 request 域中



### 5.2.2 getHandler() 方法 - 根据请求找到目标方法

- 返回值：会返回目标处理器类的**执行链**，其中包括了对应的目标方法(handler属性)
  <img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20200903113818586.png" alt="image-20200903113818586" style="zoom:80%;" />

- 源码分析

  ```java
  protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {
      if (this.handlerMappings != null) {
          for (HandlerMapping mapping : this.handlerMappings) {
              HandlerExecutionChain handler = mapping.getHandler(request);
              if (handler != null) {
                  return handler;
              }
          }
      }
      return null;
  }
  ```

  

  - HandlerMapping - 处理器映射：里面会保存每一个处理(控制)器 和 可以处理的请求信息 的映射关系
    ![image-20200903114706782](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20200903114706782.png)

  - mapping.getHandler(request)：获取对应请求地址的 handler 处理器(控制器)
    <img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20200903122550521.png" alt="image-20200903122550521" style="zoom:80%;" />

  - HandlerMapping是何时保存映射信息的？

    \- 在 IOC 容器启动时，创建 @Controller 对象时会扫描每个目标方法可以处理什么请求(参考 @RequestMapping 属性的值)
      请求时，查看对应的 HandlerMapping 即可



### 5.2.3 getHandlerAdapter - 根据处理器找到适配器

- 源码分析

  ```java
  protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException {
      if (this.handlerAdapters != null) {
          for (HandlerAdapter adapter : this.handlerAdapters) {
              if (adapter.supports(handler)) {
                  return adapter;
              }
          }
      }
      throw new ServletException("No adapter for handler [" + handler +
                                 "]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler");
  }
  ```

  - handlerAdapters：就是适配器的集合，一共有4种适配器
    ![image-20200903123753467](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20200903123753467.png)
  - adapter.supports()：通过不同的验证方法判断该指定的 handler 是否符合该适配器



## 5.3 SpringMVC 九大组件

### 5.3.1 分类

> SpringMVC 的工作过程中，其关键功能都是由以下组件完成的

```java
/** 文件上传解析器 */
@Nullable
private MultipartResolver multipartResolver;

/** 区域信息解析器(和国际化有关) */
@Nullable
private LocaleResolver localeResolver;

/** 主体解析器(支持主体更换，但基本不用) */
@Nullable
private ThemeResolver themeResolver;

/** HandlerMapping 负责保存对应的 handler映射信息 */
@Nullable
private List<HandlerMapping> handlerMappings;

/** HandlerAdapter 是 handler 的映射器  */
@Nullable
private List<HandlerAdapter> handlerAdapters;

/** SpirngMVC的异常解析功能 */
@Nullable
private List<HandlerExceptionResolver> handlerExceptionResolvers;

/** 将请求地址转换为视图名(不常用) */
@Nullable
private RequestToViewNameTranslator viewNameTranslator;

/** SpringMVC中允许重定向携带数据 */
@Nullable
private FlashMapManager flashMapManager;

/** 视图解析器 */
@Nullable
private List<ViewResolver> viewResolvers;
```

- 共同点：都是接口，都只定义了规范，具有非常高的**扩展性**



### 5.3.2 初始化

> Spring IOC容器创建 -> 调用onRefresh() -> 调用 initStrategies()

- DispatcherServlet 中的 initStrategies() 方法

  ```java
  protected void initStrategies(ApplicationContext context) {
      initMultipartResolver(context);
      initLocaleResolver(context);
      initThemeResolver(context);
      initHandlerMappings(context);
      initHandlerAdapters(context);
      initHandlerExceptionResolvers(context);
      initRequestToViewNameTranslator(context);
      initViewResolvers(context);
      initFlashMapManager(context);
  }
  ```

- 以分析 initHandlerMappings() 方法为例

  ```java
  DispatcherServlet 加载时，通过静态代码块private void initHandlerMappings(ApplicationContext context) {
      this.handlerMappings = null;
  
      //detectAllHandlerMappings默认为true，可以在 web.xml 中通过 <init-param> 修改
      if (this.detectAllHandlerMappings) { 
          // 使用 Bean工程 找到 HandlerMapping 所有实现类，并构成一个 Map 集合
          Map<String, HandlerMapping> matchingBeans =
              BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false);
          if (!matchingBeans.isEmpty()) { //如果 Map 集合不为空
              //初始化 handlerMappings 属性为构成 HandlerMapping实现类 的集合
              this.handlerMappings = new ArrayList<>(matchingBeans.values());
              // We keep HandlerMappings in sorted order.
              AnnotationAwareOrderComparator.sort(this.handlerMappings);
          }
      }
      else { 
          try { //在 IOC 容器中找到对应的组件
              HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);
              this.handlerMappings = Collections.singletonList(hm);
          }
          catch (NoSuchBeanDefinitionException ex) {
              // Ignore, we'll add a default HandlerMapping later.
          }
      }
  
  	//如果 handlerMappings 仍然为空
      if (this.handlerMappings == null) {
          /*
          (默认配置)
          getDefaultStrategies() 会从 Properties defaultStrategies 获取数据以构成集合后返回
          Properties defaultStrategies 是由 DispatcherServlet 加载时，通过静态代码块加载和 DispatcherServlet 同路径下的 DispatcherServlet.properties 文件初始化的
          */
          this.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);
          if (logger.isTraceEnabled()) {
              logger.trace("No HandlerMappings declared for servlet '" + getServletName() +
                            "': using default strategies from DispatcherServlet.properties");
          }
      }
  }
  ```

  - 基本上九大容器都是通过容器 / 默认配置初始化的

    但有部分的组件不会使用默认配置初始化，比如：MultipartResolver(详情请看该初始化方法)

    有的组件是通过类型在容器中获取的，有的组件时通过id获取的，注意区分



## 5.4 ha.handle() 执行目标方法



```
mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
		||
		||
		\/
AbstractHandlerMethodAdapter(Class) -> handle(HttpServletRequest request, HttpServletResponse response, Object handler);
		||
		||
		\/
RequestMappingHandlerAdapter(Class) -> handleInternal(HttpServletRequest request,HttpServletResponse response, HandlerMethod handlerMethod)
											||
										    \/
invokeHandlerMethod(HttpServletRequest request,HttpServletResponse response, HandlerMethod handlerMethod) - 这里会负责处理请求的包装，创建隐含模型 ModelAndView 
	||
	||
	\/
ServletInvocableHandlerMethod(class) -> invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,Object... providedArgs) - 利用反射执行目标方法，提前执行 ModelAttribute 先行方法等操作都会在这里执行
```



https://juejin.im/post/6844903911426359303#heading-2



# 第六章 视图和视图解析器

## 6.1 两个前缀的使用

### 6.1.1 forward - 请求转发

- 说明：使用前缀 forward 后，视图解析器不会为我们再拼接路径

- 使用

  ```java
  @RequestMapping("/handle01")
  public String handle01(){
      System.out.println("handle01");
      /*
      * 建议加上 / 从工程路径下出发寻找路径(绝对路径)
      * 也可以请求转发到另外一个 目标方法
      * */
      return "forward:/handle. jsp";
  }
  ```

### 6.1.2 redirect - 重定向

- 说明：使用前缀 redirect 后，视图解析器不会为我们再拼接路径

- 使用

  ```java
  @RequestMapping("/handle02")
  public String handle02(){
      System.out.println("handle02...");
      /*
      * 可以直接加上/，SpringMVC会自动帮我们加上工程路径
      * */
      return "redirect:/handle.jsp";
  }
  ```

  

## 6.2 视图解析流程

1. 在 ha.handle() 执行完目标方法后，会把方法的返回值，封装在 ModelAndView 对象中
   <img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20200904115036496.png" alt="image-20200904115036496" style="zoom:80%;" />

2. 调用  processDispatchResult() 方法

   ```java
   processDispatchResult(HttpServletRequest request, HttpServletResponse response,
                         @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,
                         @Nullable Exception exception)
   ```

   开始具体的视图渲染流程

   视图渲染流程：将域中的数据放在页面进行展示(页面就是用来渲染模型数据的)

   视图渲染流程：将域中的数据放在页面进行展示(页面就是用来渲染模型数据的)

3. 在 processDispatchResult() 中会调用 render(mv, request, response) 完成页面渲染

4. 获取 View 对象

   - View 和 ViewResolver(视图解析器)的关系

     <img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20200904115816974.png" alt="image-20200904115816974" style="zoom:80%;" />
     ViewResolver 通过视图名(方法的返回值) 和 地区信息 创建对应的 View 对象
     <img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20200905001135142.png" alt="image-20200905001135142" style="zoom:80%;" />

   - DispatcherServlet 中 resolveViewName() 方法 - 源码

     ```java
     protected View resolveViewName(String viewName, @Nullable Map<String, Object> model,
           Locale locale, HttpServletRequest request) throws Exception {
     	
        if (this.viewResolvers != null) {
           //遍历所有的 ViewResolver(视图解析器)
           for (ViewResolver viewResolver : this.viewResolvers) {
              //通过 视图解析器 创建对应的 View 对象
              View view = viewResolver.resolveViewName(viewName, locale);
              if (view != null) {
                 return view;
              }
           }
        }
        return null;
     }
     ```

- resolveViewName() 实现 - 不同的视图解析器可能有不同的实现
  这里是由我们配置的 InternalResourceViewResolver 父类 AbstractCachingViewResolver 实现的 

  ```java
  public View resolveViewName(String viewName, Locale locale) throws Exception {
      if (!isCache()) {
          return createView(viewName, locale);
      }
      else {
          Object cacheKey = getCacheKey(viewName, locale);
          View view = this.viewAccessCache.get(cacheKey);
          if (view == null) { //会现在缓存中查找，如果没有该资源对应的视图缓存就会创建一个对应的 View
              synchronized (this.viewCreationCache) {
                  view = this.viewCreationCache.get(cacheKey);
                  if (view == null) {
                      // Ask the subclass to create the View object.
                      // createView() - 通过视图名(方法的返回值)创建对应的 View
                      view = createView(viewName, locale);
                      if (view == null && this.cacheUnresolved) {
                          view = UNRESOLVED_VIEW;
                      }
                      if (view != null && this.cacheFilter.filter(view, viewName, locale)) {
                          this.viewAccessCache.put(cacheKey, view);
                          this.viewCreationCache.put(cacheKey, view);
                      }
                  }
              }
          }
          else {
              if (logger.isTraceEnabled()) {
                  logger.trace(formatKey(cacheKey) + "served from cache");
              }
          }
          return (view != UNRESOLVED_VIEW ? view : null);
      }
  }
  ```

   - createView() 方法

     ```java
     protected View createView(String viewName, Locale locale) throws Exception {
         // If this resolver is not supposed to handle the given view,
         // return null to pass on to the next resolver in the chain.
         if (!canHandle(viewName, locale)) {
             return null;
         }
     
         // REDIRECT_URL_PREFIX == "redirect:" 如果以重定向前缀开始的
         if (viewName.startsWith(REDIRECT_URL_PREFIX)) {
             String redirectUrl = viewName.substring(REDIRECT_URL_PREFIX.length());
             //创建对应重定向的视图对象
             RedirectView view = new RedirectView(redirectUrl,
                                                  isRedirectContextRelative(), isRedirectHttp10Compatible());
             String[] hosts = getRedirectHosts();
             if (hosts != null) {
                 view.setHosts(hosts);
             }
             return applyLifecycleMethods(REDIRECT_URL_PREFIX, view);
         }
     
         // FORWARD_URL_PREFIX ==  "forward:" 如果是以请求转发前缀开始的.
         if (viewName.startsWith(FORWARD_URL_PREFIX)) {
             String forwardUrl = viewName.substring(FORWARD_URL_PREFIX.length());
             // 创建一个对象 请求转发 的视图对象
             InternalResourceView view = new InternalResourceView(forwardUrl);
             return applyLifecycleMethods(FORWARD_URL_PREFIX, view);
         }
     
      // 如果没有前缀，就调用父类的方法创建视图对象
         return super.createView(viewName, locale);
      }
     ```

5. 返回 View

   - 回到 resolveViewName() 中
     ！注意：不同视图解析器创建的 View 对象类型可能是不同的 ，这里以创建 **JstlView** 类型的视图为例 

   ```java
   protected View resolveViewName(String viewName, @Nullable Map<String, Object> model,
         Locale locale, HttpServletRequest request) throws Exception {
   	
      if (this.viewResolvers != null) {
         /*
         遍历所有的 ViewResolver(视图解析器)
         如果该 配置的视图解析器 可以创建对应的 View 对象
         
         就返回该 view 对象
         得不到就遍历下一个
         */
         for (ViewResolver viewResolver : this.viewResolvers) {
            //通过 视图解析器 创建对应的 View 对象
            View view = viewResolver.resolveViewName(viewName, locale);
            if (view != null) {
               return view;
            }
         }
      }
      return null;
   }
   ```

   - 回到 DisptacherServlet 中的 render() 方法

     ​				||

     ​				\ /

     调用对应视图对象 view 实现的 reader() 方法
     <img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20200905000652087.png" alt="image-20200905000652087" style="zoom:80%;" />

   - 这里调用的是由 AbstractView 视图类实现的 reader 方法
     不同视图解析创建出来的视图对象类型可能不同

     ```java
     public void render(@Nullable Map<String, ?> model, HttpServletRequest request,
     			HttpServletResponse response) throws Exception {
     
         if (logger.isDebugEnabled()) {
             logger.debug("View " + formatViewName() +
                          ", model " + (model != null ? model : Collections.emptyMap()) +
                          (this.staticAttributes.isEmpty() ? "" : ", static attributes " + this.staticAttributes));
         }
     	
         //整合输出模型中的数据，得到一个 Map
         Map<String, Object> mergedModel = createMergedOutputModel(model, request, response);
         prepareResponse(request, response);
         //渲染要给页面输出的所有数据
         renderMergedOutputModel(mergedModel, getRequestToExpose(request), response);
     }
     ```

   - 来到 InternalResourceView 中的 renderMergedOutputModel() 方法

     ```java
     protected void renderMergedOutputModel(
         Map<String, Object> model, HttpServletRequest request, HttpServletResponse response) throws Exception {
     
         // 将隐含模型的数据封装到 request 域中
         exposeModelAsRequestAttributes(model, request);
     
         // Expose helpers as request attributes, if any.
         exposeHelpers(request);
     
         // 获取到请求转发的资源路径
         String dispatcherPath = prepareForRendering(request, response);
     
         // 得到请求转发器
         RequestDispatcher rd = getRequestDispatcher(request, dispatcherPath);
         if (rd == null) {
             throw new ServletException("Could not get RequestDispatcher for [" + getUrl() +
                                        "]: Check that the corresponding file exists within your web application archive!");
         }
     
         // If already included or response already committed, perform include, else forward.
         if (useInclude(request, response)) {
             response.setContentType(getContentType());
             if (logger.isDebugEnabled()) {
                 logger.debug("Including [" + getUrl() + "]");
             }
             rd.include(request, response);
         }
     
         else {
             // Note: The forwarded resource is supposed to determine the content type itself.
             if (logger.isDebugEnabled()) {
                 logger.debug("Forwarding to [" + getUrl() + "]");
             }
             //请求转发
             rd.forward(request, response);
         }
     }
     ```

6. 总结：
   视图解析器负责得到对应的视图对象
   视图对象转发(在此还会将模型数据保存到请求域中)/重定向到页面
   视图对象才能真正的渲染视图



## 6.3 视图解析相关概念

### 6.3.1 说明

1. 视图的作用就是**渲染数据模型**，将模型里的数据以某种形式呈现给客户

2. 为了实现 视图模型 和 具体实现技术 的解耦，Spring定义了一个高度抽象的 View 接口
   <img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20200905135920780.png" alt="image-20200905135920780" style="zoom:80%;" />

3. 视图对象有视图解析负责实例化，由于视图是**无状态**的，所以他们不会有**线程安全问题**

   - 无状态：
     对于新的请求，都会通过视图解析器创建对应的视图对象，但为了加快反应速度，会缓存该视图

     对于不是新的请求，**上一次请求和下一次请求之间的数据不会互相影响的**，即使视图是缓存的，其中的数据都是线程安全的

     

### 6.3.2 常用的视图实现类

| 大类     | 视图类型                      | 说明                                                         |
| -------- | ----------------------------- | ------------------------------------------------------------ |
| 资源视图 | **InternalResourceView**      | 将JSP或其他资源封装为视图，是InternalResourceViewResolver默认使用的视图实现类 |
| 资源视图 | **JstlView**                  | 若JSP页面使用了JSTL国际化标签的功能，则需要使用该试图类      |
| 文档视图 | **AbstractExcelView**         | Excel文档视图的抽象类，其基于POI构造Excel文档                |
| 文档视图 | AbstractPdfView               | PDF文档视图的抽象类，其基于iText构造PDF文档                  |
| 报表视图 | ConfigurableJasperReportsView | 使用JasperReports报表技术的视图                              |
| 报表视图 | JasperReportsCsvView          | 使用JasperReports报表技术的视图                              |
| 报表视图 | JasperReportsMultiFormatView  | 使用JasperReports报表技术的视图                              |
| 报表视图 | JasperReportsHtmlView         | 使用JasperReports报表技术的视图                              |
| 报表视图 | JasperReportsPdfView          | 使用JasperReports报表技术的视图                              |
| 报表视图 | JasperReportsXlsView          | 使用JasperReports报表技术的视图                              |
| JSON视图 | MappingJackson2JsonView       | 将模型数据通过Jackson开元框架的ObjectMapper以JSON方式输出    |



### 6.3.3 常见的视图解析器实现类

| 大类             | 视图类型                         | 说明                                                         |
| ---------------- | -------------------------------- | ------------------------------------------------------------ |
| 解析为Bean的名字 | **BeanNameViewResolver**         | 将逻辑视图解析为一个Bean，其id对应于逻辑视图的名称           |
| 解析为URL文件    | **InternalResourceViewResolver** | 将逻辑视图解析为一个URL文件，通常解析为一个保存在WEB-INF下的程序文件（如JSP页面） |
| 解析为URL文件    | JasperResportsViewResolver       | 将逻辑视图解析为一个报表文件对应的URL                        |
| 模板文件视图     | FreeMarkerViewResolver           | 解析为基于FreeMarker模板技术的模板文件                       |
| 模板文件视图     | VelocityViewResolver             | 解析为基于Velocity模板技术的模板文件                         |
| 模板文件视图     | VelocityLayoutViewResolver       | 解析为基于Velocity模板技术的模板文件                         |

- 每个视图解析器都实现了 Ordered 接口并开放了一个 order 属性，可以通过 order 属性指定解析器的优先顺序，order 越小优先级越高



## 6.4 JstlView 支持便捷的国际化功能

> 当我们导入 JSTL 相关的依赖/jar包时，就会自动创建 JstlView  视图对象，可以快捷方便的实现国际化功能

### 6.4.1 具体实现

1. 创建对应的国际化资源文件

2. 在 SpringMVC 配置文件中 配置一个资源文件管理器

   ```xml
   <!-- 配置资源管理器 id固定为 messageSource-->
   <bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource">
       <!-- 指定资源文件的基础名 -->
       <property name="basename" value="i18n"></property>
   </bean>
   ```

3. 在 jsp 文件中使用对应的 <fmt:message key=“”/> 即可



### 6.4.2 注意

1. 一定要经过 SpringMVC 的视图解析流程，可以通过 JstlView 快速国际化
2. 在目标方法中也不能通过 forward: 前缀请求转发到资源



### 6.4.3 使用 mvc:view-controller 将请求映射到一个页面

```xml
<!-- 使用 mvc:view-controller 标签 将一个请求映射到页面
         path:代表要对应的请求路径
         view-name:要映射到的页面地址
         在这里，仍会执行对应的 SpirngMVC 视图解析流程
-->
<mvc:view-controller path="/login" view-name="login"></mvc:view-controller>
```

在使用 mvc:view-controller 标签后，不对应 path 属性的请求会报错
可以通过开启 mvc注解开发模式解决

```xml
<!-- 开启mvc注解开发模式，解决 mvc:view-controller 的问题-->
<mvc:annotation-driven></mvc:annotation-driven>
```



## 6.5 拓展 - 自定义视图解析器和视图对象

> 视图解析器根据方法的返回值得到视图对象
>
> 多个视图解析器都会尝试能否得到视图对象
>
> 不同的视图对象具有不同的功能

1. 创建自定义视图解析器，实现 ViewResolver 接口

   ```java
   public class MyViewResolver implements ViewResolver {
   
       @Override //通过该方法创建 View 视图对象
       public View resolveViewName(String viewName, Locale locale) throws Exception {
       }
   }
   ```

2. 创建自定义视图，实现 View 接口

   ```java
   public class MyView implements View {
       @Override
       public String getContentType() {
           return null;
       }
   
       @Override //自定义实现页面渲染
       public void render(Map<String, ?> model, HttpServletRequest request, HttpServletResponse response) throws Exception {
           response.getWriter().write("EMT!!!"); //这里向页面输出数据
       }
   }
   ```

3. 在 自定义视图解析器 中创建 自定义视图 的对象

   ```java
   @Override //通过该方法创建 View 视图对象
   public View resolveViewName(String viewName, Locale locale) throws Exception {
       if(viewName.startsWith("emt:")){ //如果是 emt: 前缀
           return new MyView(); //得到自定义的视图对象
       }else{
           return null;
       }
   }
   ```

4. 在 SpringMVC 配置文件中配置自定义的视图解析器

   ```xml
   <!-- 配置自定义解析器 -->
   <bean class="pers.dreamer07.plus.MyViewResolver"></bean>
   ```

5. 通过 resolveViewName() 方法查看在工作的视图解析器
   <img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20200905203513508.png" alt="image-20200905203513508" style="zoom:80%;" />

6. 有的视图解析器可能会解析错误导致页面资源404
   这时可以通过实现 Ordered 修改优先级，使一些特定的解析器优先解析

7. 实现 Ordered 接口，order 越小，优先级越高

   ```java
   public class MyViewResolver implements ViewResolver, Ordered {
   
       private Integer order; //创建一个属性，用来设置和返回优先级
   
       @Override //返回视图的优先级
       public int getOrder() {
           return 0;
       }
   
       //自定义方法，使我们可以在 Spring 配置文件中通过 init-param 标签设置 order 属性
       public void setOrder(Integer orderId){
           this.order = orderId;
       }
   }
   ```

8. 再次配置自定义解析器及其 order 属性

   ```xml
   <!-- 配置自定义解析器 -->
   <bean class="pers.dreamer07.plus.MyViewResolver">
       <property name="order" value="1"></property>
   </bean>
   ```

9. 重新发送对应请求，查看视图解析器的优先顺序
   ![image-20200905204828520](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20200905204828520.png)

10. 解决响应中文乱码问题 -  response.setContentType("text/html"); 设置返回类型

